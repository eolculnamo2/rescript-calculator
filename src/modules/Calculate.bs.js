// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "./Utils.bs.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

var operators = [
  "+",
  "-",
  "*",
  "/",
  "="
];

var InvalidOperatorToken = /* @__PURE__ */Caml_exceptions.create("Calculate.InvalidOperatorToken");

var NoOperatorFound = /* @__PURE__ */Caml_exceptions.create("Calculate.NoOperatorFound");

var InvalidFinalToken = /* @__PURE__ */Caml_exceptions.create("Calculate.InvalidFinalToken");

var NaNException = /* @__PURE__ */Caml_exceptions.create("Calculate.NaNException");

function mapStringToToken(str) {
  switch (str) {
    case "*" :
        return /* Multiply */2;
    case "+" :
        return /* Add */0;
    case "-" :
        return /* Subtract */1;
    case "/" :
        return /* Divide */3;
    default:
      throw {
            RE_EXN_ID: InvalidOperatorToken,
            _1: str,
            Error: new Error()
          };
  }
}

function combineNumericSymbols(symbols) {
  var combinedNumString = {
    contents: ""
  };
  var reducedSymbols = Belt_Array.reduce(symbols, [], (function (agg, cur) {
          var match = Belt_Float.fromString(cur);
          if (match !== undefined) {
            combinedNumString.contents = combinedNumString.contents + cur;
            return agg;
          }
          var n = Belt_Option.getExn(Belt_Float.fromString(combinedNumString.contents));
          combinedNumString.contents = "";
          return Belt_Array.concat(agg, [
                      {
                        TAG: /* Number */1,
                        _0: n
                      },
                      {
                        TAG: /* Operator */0,
                        _0: mapStringToToken(cur)
                      }
                    ]);
        }));
  return Belt_Array.concat(reducedSymbols, [{
                TAG: /* Number */1,
                _0: Belt_Option.getExn(Belt_Float.fromString(combinedNumString.contents))
              }]);
}

function resolveOperator(a, b, operator) {
  switch (operator) {
    case /* Add */0 :
        return a + b;
    case /* Subtract */1 :
        return a - b;
    case /* Multiply */2 :
        return a * b;
    case /* Divide */3 :
        return a / b;
    
  }
}

function compute(_tokens) {
  while(true) {
    var tokens = _tokens;
    var priorityOperatorIndex = Belt_Array.getIndexBy(tokens, (function (a) {
            if (a.TAG === /* Operator */0) {
              return a._0 >= 2;
            } else {
              return false;
            }
          }));
    var match;
    if (priorityOperatorIndex !== undefined) {
      match = [
        priorityOperatorIndex,
        Belt_Option.getExn(Belt_Array.get(tokens, priorityOperatorIndex))
      ];
    } else {
      var secondaryOperatorIndex = Belt_Array.getIndexBy(tokens, (function (a) {
              if (a.TAG === /* Operator */0) {
                return a._0 < 2;
              } else {
                return false;
              }
            }));
      if (secondaryOperatorIndex !== undefined) {
        match = [
          secondaryOperatorIndex,
          Belt_Option.getExn(Belt_Array.get(tokens, secondaryOperatorIndex))
        ];
      } else {
        throw {
              RE_EXN_ID: NoOperatorFound,
              Error: new Error()
            };
      }
    }
    var operator = match[1];
    var i = match[0];
    var beforeFloat = Belt_Array.get(tokens, i - 1 | 0);
    var afterFloat = Belt_Array.get(tokens, i + 1 | 0);
    var subtotal = beforeFloat !== undefined ? (
        beforeFloat.TAG === /* Operator */0 ? 0 : (
            afterFloat !== undefined ? (
                afterFloat.TAG === /* Operator */0 ? 0 : (
                    operator.TAG === /* Operator */0 ? resolveOperator(beforeFloat._0, afterFloat._0, operator._0) : 0
                  )
              ) : 0
          )
      ) : 0;
    var newTokens = tokens.filter((function(i){
        return function (param, ind) {
          if (ind !== i && ind !== (i - 1 | 0)) {
            return ind !== (i + 1 | 0);
          } else {
            return false;
          }
        }
        }(i)));
    var setIndex = Math.max(i - 1 | 0, 0);
    var match$1 = newTokens.length;
    if (match$1 === 0) {
      return subtotal;
    }
    if (match$1 !== 1) {
      _tokens = Utils.$$Array.insertAtIndex(newTokens, setIndex, {
            TAG: /* Number */1,
            _0: subtotal
          });
      continue ;
    }
    var a = Belt_Option.getExn(Belt_Array.get(newTokens, 0));
    if (a.TAG !== /* Operator */0) {
      return a._0;
    }
    throw {
          RE_EXN_ID: InvalidFinalToken,
          Error: new Error()
        };
  };
}

function computeOrReturn(combinedSymbols) {
  var match = combinedSymbols.length;
  if (match === 0) {
    return 0;
  }
  if (match !== 1) {
    return compute(combinedSymbols);
  }
  var n = Belt_Option.getExn(Belt_Array.get(combinedSymbols, 0));
  if (n.TAG !== /* Operator */0) {
    return n._0;
  }
  throw {
        RE_EXN_ID: NaNException,
        Error: new Error()
      };
}

function make(symbols) {
  if (symbols.length === 0) {
    return 0;
  } else {
    return computeOrReturn(combineNumericSymbols(symbols));
  }
}

export {
  operators ,
  InvalidOperatorToken ,
  NoOperatorFound ,
  InvalidFinalToken ,
  NaNException ,
  mapStringToToken ,
  combineNumericSymbols ,
  resolveOperator ,
  compute ,
  computeOrReturn ,
  make ,
  
}
/* No side effect */
